marker uart-start
decimal

$0230 constant U2MODE
$0232 constant U2STA
$0234 constant U2TXREG
$0236 constant U2RXREG
$0238 constant U2BRG

$0094 constant IEC0
$0096 constant IEC1
$0086 constant IFS1
$0084 constant IFS0

b0 constant U2TX
b1 constant U2RX

0 value txDone
0 value rxExp
0 value curPos

0 IEC1 !

\ untest and interrupts
: uBuf create 60 allot
does> + ;

\ baud rate in 100s of bauds
384 constant BAUD

: uartSetup
0 U2TX setPin
1 U2RX setPin
0 U2MODE !
0 U2STA !
[ Fcy 16 BAUD * 10 u/ u/ ] literal 1 - U2BRG !

\ enable Tx operation with UART and RX interrupts
$0400 U2STA !

#15 U2MODE setBit

U2RXREG @ drop

[ uBuf uartRxBuffer ] drop
;


\ Add transmit buf overflow check
: uartSend
begin
    1 8 lshift U2STA @ and 0= invert dup \ loop until this is 1
    if
    else
        1 ms
    then
until
U2TXREG ! ;

\ Add recieve buffer check
: uartRead 
rxExp 1 = if
    begin
        1 U2STA @ and 1 = \ loop until 1
        1 ms
    until
    U2RXREG @ curPos uartRxBuffer c!
    curPos 1 + to curPos
then ;


: U2RXInt [i
di
$4000 IFS1 mclr
rxExp 1 = if
    begin 1 U2STA @ and 1 =
        U2RXREG @ curPos uartRxBuffer c!
        curPos 1 + to curPos
    until
else
    begin 1 U2STA @ and 1 =
        U2RXREG @ drop
    until
then
ei
i] ;i


: U2RxIntReg
di
1 #14 lshift invert IEC1 @ and IEC1 ! ivt
\ clr IFS
#14 IFS1 clrBit
['] U2RXInt #38 int!
aivt
\ enable interrupts
1 #14 lshift IEC1 @ or IEC1 ! 
$40 U2STA mset
ei ;

: uartInit
uartSetup
$400 U2STA !
U2RxIntReg ;


\\\\\\\\\\ TODO UART TASK FROM HERE DOWN ||||||||||||||||/////////

: uNums create 5 allot
does> + ;

uNums uartTxBuf
0 value txBufPos



: uartPrintS
for
c@+ uartSend
next
drop ;


: txBufStore
1 txBufPos + to txBufPos
txBufPos 5 < if
    txBufPos 1 - uartTxBuf c!
else
    4 to txBufPos
    drop
then
;

: txBufClr
5 for
    0 r@ uartTxBuf c!
next
;

: uartBufOut
txBufPos for
    txBufPos 1 - r@ - uartTxBuf c@ >digit uartSend
next
;

: recvFin
curPos #11 > if
    curPos 2 - dup uartRxBuffer c@ $3e = if
         1 + uartRxBuffer c@ $20 = if
             0 to rxExp
        then
    then
then
 ;

 : isDelim
uartRxBuffer c@ dup $0d = if
    true
else
    false
then
swap
dup $0a = if
    true
else
    false
then
swap
$20 = if
    true
else
    false
then ;


: numEnd
uartRxBuffer c@ dup #48 < if
    drop true
else
    #57 > if
        true
    else
        false
    then
then
;

: rxExtractNum 
0
begin
    begin
        1 + 
        dup 1 - dup curPos < if
            numEnd invert
        else
            drop true
        then
    until
    dup curPos < if
        dup 1 - swap false
    else
        drop true
    then
until
;

\ TODO: SHOULD BLOCK UNTIL RX FIN
\ AND CHECK FOR FAIL ALOS ADD TIMEOUT HERE
: uartEndTrans
#13 uartSend
1 to rxExp
txBufClr
5 for
    recvFin
    5 ms
next
rxExp 0= if
    \ uart completed -> check if fail or succeed
    curPos 8 - uartRxBuffer c@ $6b = if
        0    \ "ok"
    else
        1    \ "fail"
    then
else
    \ TODO: USE A LOOP TO DETERMINE WHEN COMMS READY
    \ WILL NEED TO BE A TASK TO DO THAT -> DONT ALLOW uart calls when not Ready?
    \ Could set a variable in RX INT as Reset causes uart same as key press
    \ uart didnt complete print error
    \ SHOULD HANDLE THESE IN UI FOR NOW --------
    0 to rxExp  \ timeout
   \  50 ms
    2
then

 ;

: uartPrintSN
uartPrintS
uartBufOut
uartEndTrans
;








