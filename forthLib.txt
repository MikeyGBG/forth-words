( n -- n)
( Gets the decimal representation from a bitPos )
: getBNum 1 swap dup 0= if drop else lshift then ;

( uu -- u)
( bitMask takes a value and a bit position and returns the value at the bit )
( bitPos is NOS )
: bitMask swap getBNum and 0= if 0 else 1 then ;

( uu -- )
( expects TOS to be reg Addr and NOS to be the bitPos)
: setBit tuck @ swap getBNum or swap ! ;

( uu -- )
( see setBit )
: clrBit tuck @ swap getBNum invert and swap ! ;


: getIx swap 1 cells + @ swap cells + ;

( un -- )
( Initializes a pinvar to input or output expects a pinvar TOS and DDR NOS )
( add ans mods )
: pinInit dup @ swap 0 getIx @ rot 0= if clrBit else setBit then ;

( pinVAR TOS value NOS )
: setPin dup @ swap 1 getIx @ rot 0= if clrBit else setBit then ;

( n -- n )
( pinVar TOS )
: readPin dup @ swap 2 getIx @ @ bitMask ;

: workVarInit
[ 0 value workReg 0 value workBit 0 value workVar ] ;

: clrWorkVar
0 to workReg
0 to workBit
0 to workVar ;

workVarInit drop

: >digit #48 + ;
: <digit #48 - ;

\ converts a number into a buffer 123 -> 1 2 3
: n2b
    dup workVar u/ 10 mod dup
    0= if
        workBit 1 = if
            swap
        else
            r@ 0 = if
                swap
            else
                drop
            then
        then
    else
        swap 1 to workBit
    then
;

: num2Buff
1 to workVar
0 to workBit
5 for
    n2b
    workVar 10 * to workVar
next drop ;

: num2RevBuff
10000 to workVar
0 to workBit
5 for
    n2b
    workVar 10 u/ to workVar
next drop ;


( -- n)
\ leaves the number of cells on stack
: sp@? sp@ 2398 - 2 / ;

\ Adds a number to the buffer
( n -- ) takes a buffer as TOS
: addNumToBuff
dup @ 9999 < if
    @ 10 * + thouBuff !
then
;

: buff2Num
sp@? for
    addNumToBuff
next 
thouBuff
;
