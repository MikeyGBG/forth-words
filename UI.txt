marker UI_START
decimal
: <digit #48 - ;

2 constant LCD_ROWS    \ number of rows displayed on lcd
4 constant UI_ROWS     \ number of rows per UI screen
2 constant UI_SCREENS  \ num UI screens

0 value currScreen     \ current screen
0 value currRow        \ curr row
0 value selected       \ if row is selected

\ USER VARIABLES ACCESSIBLE TO UART TASK
0 variable trigLevL drop
0 variable delay1L drop
0 variable delay2L drop
0 variable delay3L drop
0 variable dacReadL drop
0 variable adcReadL drop
0 variable outLevsL drop

0 variable trigLevH drop
0 variable delay1H drop
0 variable delay2H drop
0 variable delay3H drop
0 variable dacReadH drop
0 variable adcReadH drop
0 variable outLevsH drop


0 value UIVar
0 value UIReg



: UIARR
create UI_SCREENS UI_ROWS 4 * * cells allot 
does> rot rot 4 * swap UI_ROWS * 4 * + cells + ;

UIARR uiArr

\ Add uart sends on select here?
: string00 s" Trig" ;

: string01 s" D1" ;

: string02 s" D2" ;

: string03  s" D3" ;

: string10 s" Ref" ;

: string11 s" Input" ;

: string12 s" Outputs" ;

: string13 s" null" ;

: stringMV s" mV" ;

: stringuS s" us" ;

: UIInit
$0c lcdSend    \ Turn the cursor and blink off
['] string00 0 0 uiArr !
trigLevL 0 0 uiArr 1 cells + !
trigLevH 0 0 uiArr 2 cells + !
['] stringMV 0 0 uiArr 3 cells + !
['] string01 0 1 uiArr !
delay1L 0 1 uiArr 1 cells + !
delay1H 0 1 uiArr 2 cells + !
['] stringuS 0 1 uiArr 3 cells + !
['] string02 0 2 uiArr !
delay2L 0 2 uiArr 1 cells + !
delay2H 0 2 uiArr 2 cells + !
['] stringuS 0 2 uiArr 3 cells + !
['] string03 0 3 uiArr !
delay3L 0 3 uiArr 1 cells + !
delay3H 0 3 uiArr 2 cells + !
['] stringuS 0 3 uiArr 3 cells + !
['] string10 1 0 uiArr !
dacReadL 1 0 uiArr 1 cells + !
dacReadH 1 0 uiArr 2 cells + !
['] stringMV 1 0 uiArr 3 cells + !
['] string11 1 1 uiArr !
adcReadL 1 1 uiArr 1 cells + !
adcReadH 1 1 uiArr 2 cells + !
['] stringMV 1 1 uiArr 3 cells + !
['] string12 1 2 uiArr !
outLevsL 1 2 uiArr 1 cells + !
outLevsH 1 2 uiArr 2 cells + !
['] stringMV 1 2 uiArr 3 cells + !
['] string13 1 3 uiArr !
outLevsL 1 3 uiArr 1 cells + !
outLevsH 1 3 uiArr 2 cells + !
['] stringMV 1 3 uiArr 3 cells + !
;

( nn -- UI_SCREEN NOS UI_ROW TOS)
: UIPrintLine
#32 lcdWrite
uiArr dup dup @ execute lcdPrintS
#32 lcdWrite
\ dup 1 cells + @ @
\ swap 2 cells + @ @ lcdPrintD
1 cells + @ @ lcdPrintN
3 cells + @ execute lcdPrintS
;

: UIPrintLineSel
$3e lcdWrite
UIPrintLine
;

: UIPrintLineOth
#32 lcdWrite
UIPrintLine
;

\ will need to modify for 4 line
: lcdNextLine
$c0 lcdSend ;

\ \ ||||||||||-- UART TASK --|||||||| | | //

\ TODO: NEED TO ADD RESETS TO CURPOS SOMEWHERE

\ TODO: ADD FLAG CHECKS FOR UART FAIL / SUCCESS
\ UART should have words for number extraction from rxBuf
: uartReadRegs
4 for
    4 r@ - to uartRegNum
    readReg
    rxExtractNum uartRxBuffer c@ <digit \ TODO Combine chars into single num
    0 uartRegNum uiArr 1 cells + @ !
next
;

: uartSaveReg
currRow to uartRegNum
setReg       \ check if uart success
drop
\ rxExtractNum \ check reg and value against adcR
;

\ Set regs to default vals
: uartInitRegs
;
\ \ -_______________END UART TASK ______//


: UIPrintOptions
 \ print rows before current
UIReg for
    currScreen currRow r@ 1 + - UIPrintLineOth
    lcdNextLine
next

\ print current row
currScreen currRow UIPrintLineSel
lcdNextLine

\ print remaining rows
LCD_ROWS 1 - UIReg - to UIVar
UIVar for 
    currScreen currRow 
    UIVar r@ - + UIPrintLineOth
    lcdNextLine
next
;

: UISelect
currScreen 0= if
    lcdClear lcdHome
    currScreen currRow uiArr dup @ execute lcdPrintS
    lcdNextLine
    lcdPrintBuff
    $ce lcdSend
    3 cells + @ execute lcdPrintS
else
    0 to selected
    UIPrintOptions
then
;

: UIPrintScreen
currRow LCD_ROWS mod to UIReg
currRow UI_ROWS < if
    lcdClear lcdHome
    selected 0= if
        UIPrintOptions
    else
        UISelect
    then
lcdHome
then
;

\ TODO ONLY LOAD txBuf on save
: UINumIn 
selected 1 = if
    addToBuff
else
    clrBuff
    txBufClr
then
;

: UIbuf2Var
thouBuff @ currScreen currRow uiArr 1 cells + @ !
millBuff @ currScreen currRow uiArr 2 cells + @ !
;

: UILeaveSelect
UINumSave
currScreen currRow uiArr 1 cells + @ @
uartReadRegs
;

\ could do inital reg reads here if start in other mode
: UIModSwitch
;

: UINumSave
UIbuf2Var
uartSaveReg
lcdClear
currScreen currRow UIPrintLineOth
lcdNextLine
s" Saved" lcdPrintS
5 ms ;

: UIVarSave 
selected 1 = if 
    UINumSave
else
    lcdClear
    s" All Vars" lcdPrintS
    lcdNextLine
    s" Saved" lcdPrintS
    5 ms
then ;

: UIVarRes 
selected 1 = if
    currScreen currRow uiArr 1 cells + @ @ thouBuff !
    currScreen currRow uiArr 2 cells + @ @ millBuff !
else
    lcdClear
    s" all Vars" lcdPrintS
    lcdNextLine
    s" Restored" 
    5 ms
then ;


marker UI_HERE